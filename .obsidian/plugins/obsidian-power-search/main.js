/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/flexsearch/dist/flexsearch.bundle.js
var require_flexsearch_bundle = __commonJS({
  "node_modules/flexsearch/dist/flexsearch.bundle.js"(exports, module) {
    (function _f(self) {
      "use strict";
      try {
        if (module)
          self = module;
      } catch (e) {
      }
      self._factory = _f;
      var t;
      function u(a2) {
        return typeof a2 !== "undefined" ? a2 : true;
      }
      function aa(a2) {
        const b2 = Array(a2);
        for (let c2 = 0; c2 < a2; c2++)
          b2[c2] = v();
        return b2;
      }
      function v() {
        return Object.create(null);
      }
      function ba(a2, b2) {
        return b2.length - a2.length;
      }
      function x(a2) {
        return typeof a2 === "string";
      }
      function C(a2) {
        return typeof a2 === "object";
      }
      function D(a2) {
        return typeof a2 === "function";
      }
      ;
      function ca(a2, b2) {
        var c2 = da;
        if (a2 && (b2 && (a2 = E(a2, b2)), this.H && (a2 = E(a2, this.H)), this.J && 1 < a2.length && (a2 = E(a2, this.J)), c2 || c2 === "")) {
          a2 = a2.split(c2);
          if (this.filter) {
            b2 = this.filter;
            c2 = a2.length;
            const d2 = [];
            for (let e = 0, f = 0; e < c2; e++) {
              const g = a2[e];
              g && !b2[g] && (d2[f++] = g);
            }
            a2 = d2;
          }
          return a2;
        }
        return a2;
      }
      const da = /[\p{Z}\p{S}\p{P}\p{C}]+/u, ea = /[\u0300-\u036f]/g;
      function fa(a2, b2) {
        const c2 = Object.keys(a2), d2 = c2.length, e = [];
        let f = "", g = 0;
        for (let h = 0, k, m; h < d2; h++)
          k = c2[h], (m = a2[k]) ? (e[g++] = F(b2 ? "(?!\\b)" + k + "(\\b|_)" : k), e[g++] = m) : f += (f ? "|" : "") + k;
        f && (e[g++] = F(b2 ? "(?!\\b)(" + f + ")(\\b|_)" : "(" + f + ")"), e[g] = "");
        return e;
      }
      function E(a2, b2) {
        for (let c2 = 0, d2 = b2.length; c2 < d2 && (a2 = a2.replace(b2[c2], b2[c2 + 1]), a2); c2 += 2)
          ;
        return a2;
      }
      function F(a2) {
        return new RegExp(a2, "g");
      }
      function ha(a2) {
        let b2 = "", c2 = "";
        for (let d2 = 0, e = a2.length, f; d2 < e; d2++)
          (f = a2[d2]) !== c2 && (b2 += c2 = f);
        return b2;
      }
      ;
      var ja = { encode: ia, F: false, G: "" };
      function ia(a2) {
        return ca.call(this, ("" + a2).toLowerCase(), false);
      }
      ;
      const ka = {}, G = {};
      function la(a2) {
        I(a2, "add");
        I(a2, "append");
        I(a2, "search");
        I(a2, "update");
        I(a2, "remove");
      }
      function I(a2, b2) {
        a2[b2 + "Async"] = function() {
          const c2 = this, d2 = arguments;
          var e = d2[d2.length - 1];
          let f;
          D(e) && (f = e, delete d2[d2.length - 1]);
          e = new Promise(function(g) {
            setTimeout(function() {
              c2.async = true;
              const h = c2[b2].apply(c2, d2);
              c2.async = false;
              g(h);
            });
          });
          return f ? (e.then(f), this) : e;
        };
      }
      ;
      function ma(a2, b2, c2, d2) {
        const e = a2.length;
        let f = [], g, h, k = 0;
        d2 && (d2 = []);
        for (let m = e - 1; 0 <= m; m--) {
          const n = a2[m], w = n.length, q = v();
          let r = !g;
          for (let l = 0; l < w; l++) {
            const p = n[l], z = p.length;
            if (z)
              for (let B = 0, A, y; B < z; B++)
                if (y = p[B], g) {
                  if (g[y]) {
                    if (!m) {
                      if (c2)
                        c2--;
                      else if (f[k++] = y, k === b2)
                        return f;
                    }
                    if (m || d2)
                      q[y] = 1;
                    r = true;
                  }
                  if (d2 && (h[y] = (A = h[y]) ? ++A : A = 1, A < e)) {
                    const H = d2[A - 2] || (d2[A - 2] = []);
                    H[H.length] = y;
                  }
                } else
                  q[y] = 1;
          }
          if (d2)
            g || (h = q);
          else if (!r)
            return [];
          g = q;
        }
        if (d2)
          for (let m = d2.length - 1, n, w; 0 <= m; m--) {
            n = d2[m];
            w = n.length;
            for (let q = 0, r; q < w; q++)
              if (r = n[q], !g[r]) {
                if (c2)
                  c2--;
                else if (f[k++] = r, k === b2)
                  return f;
                g[r] = 1;
              }
          }
        return f;
      }
      function na(a2, b2) {
        const c2 = v(), d2 = v(), e = [];
        for (let f = 0; f < a2.length; f++)
          c2[a2[f]] = 1;
        for (let f = 0, g; f < b2.length; f++) {
          g = b2[f];
          for (let h = 0, k; h < g.length; h++)
            k = g[h], c2[k] && !d2[k] && (d2[k] = 1, e[e.length] = k);
        }
        return e;
      }
      ;
      function J(a2) {
        this.l = a2 !== true && a2;
        this.cache = v();
        this.h = [];
      }
      function oa(a2, b2, c2) {
        C(a2) && (a2 = a2.query);
        let d2 = this.cache.get(a2);
        d2 || (d2 = this.search(a2, b2, c2), this.cache.set(a2, d2));
        return d2;
      }
      J.prototype.set = function(a2, b2) {
        if (!this.cache[a2]) {
          var c2 = this.h.length;
          c2 === this.l ? delete this.cache[this.h[c2 - 1]] : c2++;
          for (--c2; 0 < c2; c2--)
            this.h[c2] = this.h[c2 - 1];
          this.h[0] = a2;
        }
        this.cache[a2] = b2;
      };
      J.prototype.get = function(a2) {
        const b2 = this.cache[a2];
        if (this.l && b2 && (a2 = this.h.indexOf(a2))) {
          const c2 = this.h[a2 - 1];
          this.h[a2 - 1] = this.h[a2];
          this.h[a2] = c2;
        }
        return b2;
      };
      const qa = { memory: { charset: "latin:extra", D: 3, B: 4, m: false }, performance: { D: 3, B: 3, s: false, context: { depth: 2, D: 1 } }, match: { charset: "latin:extra", G: "reverse" }, score: { charset: "latin:advanced", D: 20, B: 3, context: { depth: 3, D: 9 } }, "default": {} };
      function ra(a2, b2, c2, d2, e, f) {
        setTimeout(function() {
          const g = a2(c2, JSON.stringify(f));
          g && g.then ? g.then(function() {
            b2.export(a2, b2, c2, d2, e + 1);
          }) : b2.export(a2, b2, c2, d2, e + 1);
        });
      }
      ;
      function K(a2, b2) {
        if (!(this instanceof K))
          return new K(a2);
        var c2;
        if (a2) {
          x(a2) ? a2 = qa[a2] : (c2 = a2.preset) && (a2 = Object.assign({}, c2[c2], a2));
          c2 = a2.charset;
          var d2 = a2.lang;
          x(c2) && (c2.indexOf(":") === -1 && (c2 += ":default"), c2 = G[c2]);
          x(d2) && (d2 = ka[d2]);
        } else
          a2 = {};
        let e, f, g = a2.context || {};
        this.encode = a2.encode || c2 && c2.encode || ia;
        this.register = b2 || v();
        this.D = e = a2.resolution || 9;
        this.G = b2 = c2 && c2.G || a2.tokenize || "strict";
        this.depth = b2 === "strict" && g.depth;
        this.l = u(g.bidirectional);
        this.s = f = u(a2.optimize);
        this.m = u(a2.fastupdate);
        this.B = a2.minlength || 1;
        this.C = a2.boost;
        this.map = f ? aa(e) : v();
        this.A = e = g.resolution || 1;
        this.h = f ? aa(e) : v();
        this.F = c2 && c2.F || a2.rtl;
        this.H = (b2 = a2.matcher || d2 && d2.H) && fa(b2, false);
        this.J = (b2 = a2.stemmer || d2 && d2.J) && fa(b2, true);
        if (c2 = b2 = a2.filter || d2 && d2.filter) {
          c2 = b2;
          d2 = v();
          for (let h = 0, k = c2.length; h < k; h++)
            d2[c2[h]] = 1;
          c2 = d2;
        }
        this.filter = c2;
        this.cache = (b2 = a2.cache) && new J(b2);
      }
      t = K.prototype;
      t.append = function(a2, b2) {
        return this.add(a2, b2, true);
      };
      t.add = function(a2, b2, c2, d2) {
        if (b2 && (a2 || a2 === 0)) {
          if (!d2 && !c2 && this.register[a2])
            return this.update(a2, b2);
          b2 = this.encode(b2);
          if (d2 = b2.length) {
            const m = v(), n = v(), w = this.depth, q = this.D;
            for (let r = 0; r < d2; r++) {
              let l = b2[this.F ? d2 - 1 - r : r];
              var e = l.length;
              if (l && e >= this.B && (w || !n[l])) {
                var f = L(q, d2, r), g = "";
                switch (this.G) {
                  case "full":
                    if (3 < e) {
                      for (f = 0; f < e; f++)
                        for (var h = e; h > f; h--)
                          if (h - f >= this.B) {
                            var k = L(q, d2, r, e, f);
                            g = l.substring(f, h);
                            M(this, n, g, k, a2, c2);
                          }
                      break;
                    }
                  case "reverse":
                    if (2 < e) {
                      for (h = e - 1; 0 < h; h--)
                        g = l[h] + g, g.length >= this.B && M(this, n, g, L(q, d2, r, e, h), a2, c2);
                      g = "";
                    }
                  case "forward":
                    if (1 < e) {
                      for (h = 0; h < e; h++)
                        g += l[h], g.length >= this.B && M(this, n, g, f, a2, c2);
                      break;
                    }
                  default:
                    if (this.C && (f = Math.min(f / this.C(b2, l, r) | 0, q - 1)), M(this, n, l, f, a2, c2), w && 1 < d2 && r < d2 - 1) {
                      for (e = v(), g = this.A, f = l, h = Math.min(w + 1, d2 - r), e[f] = 1, k = 1; k < h; k++)
                        if ((l = b2[this.F ? d2 - 1 - r - k : r + k]) && l.length >= this.B && !e[l]) {
                          e[l] = 1;
                          const p = this.l && l > f;
                          M(this, m, p ? f : l, L(g + (d2 / 2 > g ? 0 : 1), d2, r, h - 1, k - 1), a2, c2, p ? l : f);
                        }
                    }
                }
              }
            }
            this.m || (this.register[a2] = 1);
          }
        }
        return this;
      };
      function L(a2, b2, c2, d2, e) {
        return c2 && 1 < a2 ? b2 + (d2 || 0) <= a2 ? c2 + (e || 0) : (a2 - 1) / (b2 + (d2 || 0)) * (c2 + (e || 0)) + 1 | 0 : 0;
      }
      function M(a2, b2, c2, d2, e, f, g) {
        let h = g ? a2.h : a2.map;
        if (!b2[c2] || g && !b2[c2][g])
          a2.s && (h = h[d2]), g ? (b2 = b2[c2] || (b2[c2] = v()), b2[g] = 1, h = h[g] || (h[g] = v())) : b2[c2] = 1, h = h[c2] || (h[c2] = []), a2.s || (h = h[d2] || (h[d2] = [])), f && h.indexOf(e) !== -1 || (h[h.length] = e, a2.m && (a2 = a2.register[e] || (a2.register[e] = []), a2[a2.length] = h));
      }
      t.search = function(a2, b2, c2) {
        c2 || (!b2 && C(a2) ? (c2 = a2, a2 = c2.query) : C(b2) && (c2 = b2));
        let d2 = [], e;
        let f, g = 0;
        if (c2) {
          b2 = c2.limit;
          g = c2.offset || 0;
          var h = c2.context;
          f = c2.suggest;
        }
        if (a2 && (a2 = this.encode(a2), e = a2.length, 1 < e)) {
          c2 = v();
          var k = [];
          for (let n = 0, w = 0, q; n < e; n++)
            if ((q = a2[n]) && q.length >= this.B && !c2[q])
              if (this.s || f || this.map[q])
                k[w++] = q, c2[q] = 1;
              else
                return d2;
          a2 = k;
          e = a2.length;
        }
        if (!e)
          return d2;
        b2 || (b2 = 100);
        h = this.depth && 1 < e && h !== false;
        c2 = 0;
        let m;
        h ? (m = a2[0], c2 = 1) : 1 < e && a2.sort(ba);
        for (let n, w; c2 < e; c2++) {
          w = a2[c2];
          h ? (n = sa(this, d2, f, b2, g, e === 2, w, m), f && n === false && d2.length || (m = w)) : n = sa(this, d2, f, b2, g, e === 1, w);
          if (n)
            return n;
          if (f && c2 === e - 1) {
            k = d2.length;
            if (!k) {
              if (h) {
                h = 0;
                c2 = -1;
                continue;
              }
              return d2;
            }
            if (k === 1)
              return ta(d2[0], b2, g);
          }
        }
        return ma(d2, b2, g, f);
      };
      function sa(a2, b2, c2, d2, e, f, g, h) {
        let k = [], m = h ? a2.h : a2.map;
        a2.s || (m = ua(m, g, h, a2.l));
        if (m) {
          let n = 0;
          const w = Math.min(m.length, h ? a2.A : a2.D);
          for (let q = 0, r = 0, l, p; q < w; q++)
            if (l = m[q]) {
              if (a2.s && (l = ua(l, g, h, a2.l)), e && l && f && (p = l.length, p <= e ? (e -= p, l = null) : (l = l.slice(e), e = 0)), l && (k[n++] = l, f && (r += l.length, r >= d2)))
                break;
            }
          if (n) {
            if (f)
              return ta(k, d2, 0);
            b2[b2.length] = k;
            return;
          }
        }
        return !c2 && k;
      }
      function ta(a2, b2, c2) {
        a2 = a2.length === 1 ? a2[0] : [].concat.apply([], a2);
        return c2 || a2.length > b2 ? a2.slice(c2, c2 + b2) : a2;
      }
      function ua(a2, b2, c2, d2) {
        c2 ? (d2 = d2 && b2 > c2, a2 = (a2 = a2[d2 ? b2 : c2]) && a2[d2 ? c2 : b2]) : a2 = a2[b2];
        return a2;
      }
      t.contain = function(a2) {
        return !!this.register[a2];
      };
      t.update = function(a2, b2) {
        return this.remove(a2).add(a2, b2);
      };
      t.remove = function(a2, b2) {
        const c2 = this.register[a2];
        if (c2) {
          if (this.m)
            for (let d2 = 0, e; d2 < c2.length; d2++)
              e = c2[d2], e.splice(e.indexOf(a2), 1);
          else
            N(this.map, a2, this.D, this.s), this.depth && N(this.h, a2, this.A, this.s);
          b2 || delete this.register[a2];
          if (this.cache) {
            b2 = this.cache;
            for (let d2 = 0, e, f; d2 < b2.h.length; d2++)
              f = b2.h[d2], e = b2.cache[f], e.indexOf(a2) !== -1 && (b2.h.splice(d2--, 1), delete b2.cache[f]);
          }
        }
        return this;
      };
      function N(a2, b2, c2, d2, e) {
        let f = 0;
        if (a2.constructor === Array)
          if (e)
            b2 = a2.indexOf(b2), b2 !== -1 ? 1 < a2.length && (a2.splice(b2, 1), f++) : f++;
          else {
            e = Math.min(a2.length, c2);
            for (let g = 0, h; g < e; g++)
              if (h = a2[g])
                f = N(h, b2, c2, d2, e), d2 || f || delete a2[g];
          }
        else
          for (let g in a2)
            (f = N(a2[g], b2, c2, d2, e)) || delete a2[g];
        return f;
      }
      t.searchCache = oa;
      t.export = function(a2, b2, c2, d2, e) {
        let f, g;
        switch (e || (e = 0)) {
          case 0:
            f = "reg";
            if (this.m) {
              g = v();
              for (let h in this.register)
                g[h] = 1;
            } else
              g = this.register;
            break;
          case 1:
            f = "cfg";
            g = { doc: 0, opt: this.s ? 1 : 0 };
            break;
          case 2:
            f = "map";
            g = this.map;
            break;
          case 3:
            f = "ctx";
            g = this.h;
            break;
          default:
            return;
        }
        ra(a2, b2 || this, c2 ? c2 + "." + f : f, d2, e, g);
        return true;
      };
      t.import = function(a2, b2) {
        if (b2)
          switch (x(b2) && (b2 = JSON.parse(b2)), a2) {
            case "cfg":
              this.s = !!b2.opt;
              break;
            case "reg":
              this.m = false;
              this.register = b2;
              break;
            case "map":
              this.map = b2;
              break;
            case "ctx":
              this.h = b2;
          }
      };
      la(K.prototype);
      function va(a2) {
        a2 = a2.data;
        var b2 = self._index;
        const c2 = a2.args;
        var d2 = a2.task;
        switch (d2) {
          case "init":
            d2 = a2.options || {};
            a2 = a2.factory;
            b2 = d2.encode;
            d2.cache = false;
            b2 && b2.indexOf("function") === 0 && (d2.encode = Function("return " + b2)());
            a2 ? (Function("return " + a2)()(self), self._index = new self.FlexSearch.Index(d2), delete self.FlexSearch) : self._index = new K(d2);
            break;
          default:
            a2 = a2.id, b2 = b2[d2].apply(b2, c2), postMessage(d2 === "search" ? { id: a2, msg: b2 } : { id: a2 });
        }
      }
      ;
      let wa = 0;
      function O(a2) {
        if (!(this instanceof O))
          return new O(a2);
        var b2;
        a2 ? D(b2 = a2.encode) && (a2.encode = b2.toString()) : a2 = {};
        (b2 = (self || window)._factory) && (b2 = b2.toString());
        const c2 = self.exports, d2 = this;
        this.o = xa(b2, c2, a2.worker);
        this.h = v();
        if (this.o) {
          if (c2)
            this.o.on("message", function(e) {
              d2.h[e.id](e.msg);
              delete d2.h[e.id];
            });
          else
            this.o.onmessage = function(e) {
              e = e.data;
              d2.h[e.id](e.msg);
              delete d2.h[e.id];
            };
          this.o.postMessage({ task: "init", factory: b2, options: a2 });
        }
      }
      P("add");
      P("append");
      P("search");
      P("update");
      P("remove");
      function P(a2) {
        O.prototype[a2] = O.prototype[a2 + "Async"] = function() {
          const b2 = this, c2 = [].slice.call(arguments);
          var d2 = c2[c2.length - 1];
          let e;
          D(d2) && (e = d2, c2.splice(c2.length - 1, 1));
          d2 = new Promise(function(f) {
            setTimeout(function() {
              b2.h[++wa] = f;
              b2.o.postMessage({ task: a2, id: wa, args: c2 });
            });
          });
          return e ? (d2.then(e), this) : d2;
        };
      }
      function xa(a, b, c) {
        let d;
        try {
          d = b ? eval('new (require("worker_threads")["Worker"])("../dist/node/node.js")') : a ? new Worker(URL.createObjectURL(new Blob(["onmessage=" + va.toString()], { type: "text/javascript" }))) : new Worker(x(c) ? c : "worker/worker.js", { type: "module" });
        } catch (e) {
        }
        return d;
      }
      ;
      function Q(a2) {
        if (!(this instanceof Q))
          return new Q(a2);
        var b2 = a2.document || a2.doc || a2, c2;
        this.K = [];
        this.h = [];
        this.A = [];
        this.register = v();
        this.key = (c2 = b2.key || b2.id) && S(c2, this.A) || "id";
        this.m = u(a2.fastupdate);
        this.C = (c2 = b2.store) && c2 !== true && [];
        this.store = c2 && v();
        this.I = (c2 = b2.tag) && S(c2, this.A);
        this.l = c2 && v();
        this.cache = (c2 = a2.cache) && new J(c2);
        a2.cache = false;
        this.o = a2.worker;
        this.async = false;
        c2 = v();
        let d2 = b2.index || b2.field || b2;
        x(d2) && (d2 = [d2]);
        for (let e = 0, f, g; e < d2.length; e++)
          f = d2[e], x(f) || (g = f, f = f.field), g = C(g) ? Object.assign({}, a2, g) : a2, this.o && (c2[f] = new O(g), c2[f].o || (this.o = false)), this.o || (c2[f] = new K(g, this.register)), this.K[e] = S(f, this.A), this.h[e] = f;
        if (this.C)
          for (a2 = b2.store, x(a2) && (a2 = [a2]), b2 = 0; b2 < a2.length; b2++)
            this.C[b2] = S(a2[b2], this.A);
        this.index = c2;
      }
      function S(a2, b2) {
        const c2 = a2.split(":");
        let d2 = 0;
        for (let e = 0; e < c2.length; e++)
          a2 = c2[e], 0 <= a2.indexOf("[]") && (a2 = a2.substring(0, a2.length - 2)) && (b2[d2] = true), a2 && (c2[d2++] = a2);
        d2 < c2.length && (c2.length = d2);
        return 1 < d2 ? c2 : c2[0];
      }
      function T(a2, b2) {
        if (x(b2))
          a2 = a2[b2];
        else
          for (let c2 = 0; a2 && c2 < b2.length; c2++)
            a2 = a2[b2[c2]];
        return a2;
      }
      function U(a2, b2, c2, d2, e) {
        a2 = a2[e];
        if (d2 === c2.length - 1)
          b2[e] = a2;
        else if (a2)
          if (a2.constructor === Array)
            for (b2 = b2[e] = Array(a2.length), e = 0; e < a2.length; e++)
              U(a2, b2, c2, d2, e);
          else
            b2 = b2[e] || (b2[e] = v()), e = c2[++d2], U(a2, b2, c2, d2, e);
      }
      function V(a2, b2, c2, d2, e, f, g, h) {
        if (a2 = a2[g])
          if (d2 === b2.length - 1) {
            if (a2.constructor === Array) {
              if (c2[d2]) {
                for (b2 = 0; b2 < a2.length; b2++)
                  e.add(f, a2[b2], true, true);
                return;
              }
              a2 = a2.join(" ");
            }
            e.add(f, a2, h, true);
          } else if (a2.constructor === Array)
            for (g = 0; g < a2.length; g++)
              V(a2, b2, c2, d2, e, f, g, h);
          else
            g = b2[++d2], V(a2, b2, c2, d2, e, f, g, h);
      }
      t = Q.prototype;
      t.add = function(a2, b2, c2) {
        C(a2) && (b2 = a2, a2 = T(b2, this.key));
        if (b2 && (a2 || a2 === 0)) {
          if (!c2 && this.register[a2])
            return this.update(a2, b2);
          for (let d2 = 0, e, f; d2 < this.h.length; d2++)
            f = this.h[d2], e = this.K[d2], x(e) && (e = [e]), V(b2, e, this.A, 0, this.index[f], a2, e[0], c2);
          if (this.I) {
            let d2 = T(b2, this.I), e = v();
            x(d2) && (d2 = [d2]);
            for (let f = 0, g, h; f < d2.length; f++)
              if (g = d2[f], !e[g] && (e[g] = 1, h = this.l[g] || (this.l[g] = []), !c2 || h.indexOf(a2) === -1)) {
                if (h[h.length] = a2, this.m) {
                  const k = this.register[a2] || (this.register[a2] = []);
                  k[k.length] = h;
                }
              }
          }
          if (this.store && (!c2 || !this.store[a2])) {
            let d2;
            if (this.C) {
              d2 = v();
              for (let e = 0, f; e < this.C.length; e++)
                f = this.C[e], x(f) ? d2[f] = b2[f] : U(b2, d2, f, 0, f[0]);
            }
            this.store[a2] = d2 || b2;
          }
        }
        return this;
      };
      t.append = function(a2, b2) {
        return this.add(a2, b2, true);
      };
      t.update = function(a2, b2) {
        return this.remove(a2).add(a2, b2);
      };
      t.remove = function(a2) {
        C(a2) && (a2 = T(a2, this.key));
        if (this.register[a2]) {
          for (var b2 = 0; b2 < this.h.length && (this.index[this.h[b2]].remove(a2, !this.o), !this.m); b2++)
            ;
          if (this.I && !this.m)
            for (let c2 in this.l) {
              b2 = this.l[c2];
              const d2 = b2.indexOf(a2);
              d2 !== -1 && (1 < b2.length ? b2.splice(d2, 1) : delete this.l[c2]);
            }
          this.store && delete this.store[a2];
          delete this.register[a2];
        }
        return this;
      };
      t.search = function(a2, b2, c2, d2) {
        c2 || (!b2 && C(a2) ? (c2 = a2, a2 = c2.query) : C(b2) && (c2 = b2, b2 = 0));
        let e = [], f = [], g, h, k, m, n, w, q = 0;
        if (c2)
          if (c2.constructor === Array)
            k = c2, c2 = null;
          else {
            k = (g = c2.pluck) || c2.index || c2.field;
            m = c2.tag;
            h = this.store && c2.enrich;
            n = c2.bool === "and";
            b2 = c2.limit || 100;
            w = c2.offset || 0;
            if (m && (x(m) && (m = [m]), !a2)) {
              for (let l = 0, p; l < m.length; l++)
                if (p = ya.call(this, m[l], b2, w, h))
                  e[e.length] = p, q++;
              return q ? e : [];
            }
            x(k) && (k = [k]);
          }
        k || (k = this.h);
        n = n && (1 < k.length || m && 1 < m.length);
        const r = !d2 && (this.o || this.async) && [];
        for (let l = 0, p, z, B; l < k.length; l++) {
          let A;
          z = k[l];
          x(z) || (A = z, z = z.field);
          if (r)
            r[l] = this.index[z].searchAsync(a2, b2, A || c2);
          else {
            d2 ? p = d2[l] : p = this.index[z].search(a2, b2, A || c2);
            B = p && p.length;
            if (m && B) {
              const y = [];
              let H = 0;
              n && (y[0] = [p]);
              for (let X = 0, pa, R; X < m.length; X++)
                if (pa = m[X], B = (R = this.l[pa]) && R.length)
                  H++, y[y.length] = n ? [R] : R;
              H && (p = n ? ma(y, b2 || 100, w || 0) : na(p, y), B = p.length);
            }
            if (B)
              f[q] = z, e[q++] = p;
            else if (n)
              return [];
          }
        }
        if (r) {
          const l = this;
          return new Promise(function(p) {
            Promise.all(r).then(function(z) {
              p(l.search(a2, b2, c2, z));
            });
          });
        }
        if (!q)
          return [];
        if (g && (!h || !this.store))
          return e[0];
        for (let l = 0, p; l < f.length; l++) {
          p = e[l];
          p.length && h && (p = za.call(this, p));
          if (g)
            return p;
          e[l] = { field: f[l], result: p };
        }
        return e;
      };
      function ya(a2, b2, c2, d2) {
        let e = this.l[a2], f = e && e.length - c2;
        if (f && 0 < f) {
          if (f > b2 || c2)
            e = e.slice(c2, c2 + b2);
          d2 && (e = za.call(this, e));
          return { tag: a2, result: e };
        }
      }
      function za(a2) {
        const b2 = Array(a2.length);
        for (let c2 = 0, d2; c2 < a2.length; c2++)
          d2 = a2[c2], b2[c2] = { id: d2, doc: this.store[d2] };
        return b2;
      }
      t.contain = function(a2) {
        return !!this.register[a2];
      };
      t.get = function(a2) {
        return this.store[a2];
      };
      t.set = function(a2, b2) {
        this.store[a2] = b2;
        return this;
      };
      t.searchCache = oa;
      t.export = function(a2, b2, c2, d2, e) {
        e || (e = 0);
        d2 || (d2 = 0);
        if (d2 < this.h.length) {
          const f = this.h[d2], g = this.index[f];
          b2 = this;
          setTimeout(function() {
            g.export(a2, b2, e ? f.replace(":", "-") : "", d2, e++) || (d2++, e = 1, b2.export(a2, b2, f, d2, e));
          });
        } else {
          let f;
          switch (e) {
            case 1:
              c2 = "tag";
              f = this.l;
              break;
            case 2:
              c2 = "store";
              f = this.store;
              break;
            default:
              return;
          }
          ra(a2, this, c2, d2, e, f);
        }
      };
      t.import = function(a2, b2) {
        if (b2)
          switch (x(b2) && (b2 = JSON.parse(b2)), a2) {
            case "tag":
              this.l = b2;
              break;
            case "reg":
              this.m = false;
              this.register = b2;
              for (let d2 = 0, e; d2 < this.h.length; d2++)
                e = this.index[this.h[d2]], e.register = b2, e.m = false;
              break;
            case "store":
              this.store = b2;
              break;
            default:
              a2 = a2.split(".");
              const c2 = a2[0];
              a2 = a2[1];
              c2 && a2 && this.index[c2].import(a2, b2);
          }
      };
      la(Q.prototype);
      var Ba = { encode: Aa, F: false, G: "" };
      const Ca = [F("[\xE0\xE1\xE2\xE3\xE4\xE5]"), "a", F("[\xE8\xE9\xEA\xEB]"), "e", F("[\xEC\xED\xEE\xEF]"), "i", F("[\xF2\xF3\xF4\xF5\xF6\u0151]"), "o", F("[\xF9\xFA\xFB\xFC\u0171]"), "u", F("[\xFD\u0177\xFF]"), "y", F("\xF1"), "n", F("[\xE7c]"), "k", F("\xDF"), "s", F(" & "), " and "];
      function Aa(a2) {
        var b2 = a2;
        b2.normalize && (b2 = b2.normalize("NFD").replace(ea, ""));
        return ca.call(this, b2.toLowerCase(), !a2.normalize && Ca);
      }
      ;
      var Ea = { encode: Da, F: false, G: "strict" };
      const Fa = /[^a-z0-9]+/, Ga = { b: "p", v: "f", w: "f", z: "s", x: "s", "\xDF": "s", d: "t", n: "m", c: "k", g: "k", j: "k", q: "k", i: "e", y: "e", u: "o" };
      function Da(a2) {
        a2 = Aa.call(this, a2).join(" ");
        const b2 = [];
        if (a2) {
          const c2 = a2.split(Fa), d2 = c2.length;
          for (let e = 0, f, g = 0; e < d2; e++)
            if ((a2 = c2[e]) && (!this.filter || !this.filter[a2])) {
              f = a2[0];
              let h = Ga[f] || f, k = h;
              for (let m = 1; m < a2.length; m++) {
                f = a2[m];
                const n = Ga[f] || f;
                n && n !== k && (h += n, k = n);
              }
              b2[g++] = h;
            }
        }
        return b2;
      }
      ;
      var Ia = { encode: Ha, F: false, G: "" };
      const Ja = [F("ae"), "a", F("oe"), "o", F("sh"), "s", F("th"), "t", F("ph"), "f", F("pf"), "f", F("(?![aeo])h(?![aeo])"), "", F("(?!^[aeo])h(?!^[aeo])"), ""];
      function Ha(a2, b2) {
        a2 && (a2 = Da.call(this, a2).join(" "), 2 < a2.length && (a2 = E(a2, Ja)), b2 || (1 < a2.length && (a2 = ha(a2)), a2 && (a2 = a2.split(" "))));
        return a2;
      }
      ;
      var La = { encode: Ka, F: false, G: "" };
      const Ma = F("(?!\\b)[aeo]");
      function Ka(a2) {
        a2 && (a2 = Ha.call(this, a2, true), 1 < a2.length && (a2 = a2.replace(Ma, "")), 1 < a2.length && (a2 = ha(a2)), a2 && (a2 = a2.split(" ")));
        return a2;
      }
      ;
      G["latin:default"] = ja;
      G["latin:simple"] = Ba;
      G["latin:balance"] = Ea;
      G["latin:advanced"] = Ia;
      G["latin:extra"] = La;
      const W = self;
      let Y;
      const Z = { Index: K, Document: Q, Worker: O, registerCharset: function(a2, b2) {
        G[a2] = b2;
      }, registerLanguage: function(a2, b2) {
        ka[a2] = b2;
      } };
      (Y = W.define) && Y.amd ? Y([], function() {
        return Z;
      }) : W.exports ? W.exports = Z : W.FlexSearch = Z;
    })(exports);
  }
});

// src/main.ts
__export(exports, {
  default: () => PowerSearch
});
var import_obsidian7 = __toModule(require("obsidian"));

// src/constants.ts
var SEARCH_RESULT_VIEW_TYPE = "search-result-view";

// src/core/anki.ts
var import_obsidian2 = __toModule(require("obsidian"));

// src/index.ts
var import_obsidian = __toModule(require("obsidian"));
var SearchIndex = class {
  constructor(searcher, type) {
    this.searcher = searcher;
    this.plugin = this.searcher.plugin;
    this.type = type;
    this.notes = [];
    this.errorShown = 0;
    this.plugin.indexes.push(this);
    this.setupIndex(true);
  }
  setupIndex(load = false) {
    return __async(this, null, function* () {
      if (this.plugin.settings.indexes[this.type]) {
        this.searcher.addIndexIfNotAlreadyAdded(this);
      } else if (!load)
        yield this.searcher.removeIndex(this);
    });
  }
  loadNotes() {
    return __async(this, null, function* () {
      try {
        let origNotes = yield this.getOriginalNotes();
        this.beforeProduction(origNotes);
        this.notes = [];
        for (let o of origNotes) {
          this.notes.push({
            id: this.getIdFromOriginal(o),
            link: this.getLinkFromOriginal(o),
            name: this.getNameFromOriginal(o),
            type: this.type,
            search: yield this.getRawSearchDataFromOriginal(o),
            original: o
          });
        }
        return true;
      } catch (error) {
        if (!this.notes)
          this.notes = [];
        console.log(error);
        if (this.errorShown <= 2) {
          new import_obsidian.Notice(`Failed to load notes for the index of type: ${this.type}, see debugging log`);
          this.errorShown += 1;
        }
        return false;
      }
    });
  }
};

// src/utils.ts
function stripHTML(html) {
  let doc = new DOMParser().parseFromString(html, "text/html");
  return doc.body.textContent || "";
}

// src/core/anki.ts
var AnkiIndex = class extends SearchIndex {
  constructor(searcher) {
    super(searcher, "Anki Note");
    this.plugin.registerObsidianProtocolHandler("anki", (params) => invoke("guiBrowse", { query: `nid:${params.id}` }));
  }
  getOriginalNotes() {
    return __async(this, null, function* () {
      let ids = yield invoke("findNotes", { query: "deck:*" });
      let notes = yield invoke("notesInfo", { notes: ids });
      return notes;
    });
  }
  getIdFromOriginal(original) {
    return original.noteId;
  }
  getNameFromOriginal(original) {
    return original.noteId.toString();
  }
  getLinkFromOriginal(original) {
    return "obsidian://anki?" + String.raw`&id=` + encodeURIComponent(original.noteId);
  }
  getRawSearchDataFromOriginal(original) {
    return __async(this, null, function* () {
      return stripHTML(this.getFieldsText(original));
    });
  }
  getDisplayFromOriginal(original) {
    return __async(this, null, function* () {
      let htmlEl = createDiv({ cls: "power-search-results-card" });
      htmlEl.innerHTML = this.getFieldsText(original);
      this.renderMathForNote(htmlEl);
      yield this.fixImagesForNote(htmlEl);
      return htmlEl;
    });
  }
  beforeProduction(origNotes) {
    return __async(this, null, function* () {
    });
  }
  getFieldsText(original) {
    let fieldsText = "";
    for (let field in original.fields) {
      fieldsText += `${original.fields[field].value} |`;
    }
    return fieldsText;
  }
  renderMathForNote(el) {
    let str = el.innerHTML;
    let startDelimIndex = str.indexOf("\\(");
    let endDelimIndex = str.indexOf("\\)");
    let startIndex = 0;
    let strList = [];
    while (startDelimIndex != -1 && endDelimIndex != -1) {
      strList.push(str.substring(startIndex, startDelimIndex));
      let substring = str.substring(startDelimIndex + 2, endDelimIndex);
      strList.push((0, import_obsidian2.renderMath)(substring, true).innerHTML);
      startIndex = endDelimIndex + 2;
      startDelimIndex = str.indexOf("\\(", startIndex);
      endDelimIndex = str.indexOf("\\)", startIndex);
    }
    strList.push(str.substring(startIndex));
    el.innerHTML = strList.join("");
  }
  fixImagesForNote(el) {
    return __async(this, null, function* () {
      let imgs = Array.from(el.getElementsByTagName("img"));
      for (let img of imgs) {
        let imgBase64 = yield invoke("retrieveMediaFile", { filename: img.alt });
        img.src = `data:image/png;base64, ${imgBase64}`;
      }
      ;
    });
  }
};
var ANKI_PORT = 8765;
function invoke(action, params = {}) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.addEventListener("error", () => reject("failed to issue request"));
    xhr.addEventListener("load", () => {
      try {
        const response = JSON.parse(xhr.responseText);
        if (Object.getOwnPropertyNames(response).length != 2) {
          throw "response has an unexpected number of fields";
        }
        if (!response.hasOwnProperty("error")) {
          throw "response is missing required error field";
        }
        if (!response.hasOwnProperty("result")) {
          throw "response is missing required result field";
        }
        if (response.error) {
          throw response.error;
        }
        resolve(response.result);
      } catch (e) {
        reject(e);
      }
    });
    xhr.open("POST", "http://127.0.0.1:" + ANKI_PORT.toString());
    xhr.send(JSON.stringify({ action, version: 6, params }));
  });
}

// src/core/obs.ts
var import_obsidian3 = __toModule(require("obsidian"));
var ObsidianIndex = class extends SearchIndex {
  constructor(searcher) {
    super(searcher, "Obsidian File");
    this.fileTexts = {};
    this.modifiedFiles = [];
    this.firstLoad = true;
    this.plugin.app.vault.on("modify", (f) => this.onModify(f));
    this.plugin.app.vault.on("delete", (f) => this.onDelete(f));
    this.plugin.app.vault.on("create", (f) => this.onCreate(f));
  }
  onModify(f) {
    if (f instanceof import_obsidian3.TFile && this.modifiedFiles.indexOf(f) == -1)
      this.modifiedFiles.push(f);
  }
  onDelete(f) {
    if (f instanceof import_obsidian3.TFile && f.path in this.fileTexts)
      delete this.fileTexts[f.path];
  }
  onCreate(f) {
    return __async(this, null, function* () {
      if (f instanceof import_obsidian3.TFile)
        this.fileTexts[f.path] = yield this.plugin.app.vault.cachedRead(f);
    });
  }
  getOriginalNotes() {
    return __async(this, null, function* () {
      return this.plugin.app.vault.getMarkdownFiles();
    });
  }
  getNameFromOriginal(original) {
    return original.name;
  }
  getIdFromOriginal(original) {
    return original.path;
  }
  getRawSearchDataFromOriginal(original) {
    return __async(this, null, function* () {
      return this.fileTexts[original.path];
    });
  }
  getDisplayFromOriginal(original) {
    return __async(this, null, function* () {
      let el = createDiv({ cls: "power-search-results-card" });
      import_obsidian3.MarkdownRenderer.renderMarkdown(this.fileTexts[original.path], el, original.path, this.searcher.plugin.getView());
      return el;
    });
  }
  beforeProduction(origNotes) {
    return __async(this, null, function* () {
      if (this.firstLoad)
        for (let n of origNotes) {
          this.fileTexts[n.path] = yield this.plugin.app.vault.read(n);
        }
      else {
        for (let f of this.modifiedFiles)
          this.fileTexts[f.path] = yield this.plugin.app.vault.cachedRead(f);
      }
      this.firstLoad = false;
      this.modifiedFiles = [];
    });
  }
  getLinkFromOriginal(original) {
    let vaultName = this.plugin.app.vault.getName();
    return "obsidian://open?vault=" + encodeURIComponent(vaultName) + String.raw`&file=` + encodeURIComponent(original.path);
  }
};

// src/search.ts
var import_flexsearch = __toModule(require_flexsearch_bundle());
var import_obsidian4 = __toModule(require("obsidian"));

// node_modules/stemmer/index.js
var step2list = {
  ational: "ate",
  tional: "tion",
  enci: "ence",
  anci: "ance",
  izer: "ize",
  bli: "ble",
  alli: "al",
  entli: "ent",
  eli: "e",
  ousli: "ous",
  ization: "ize",
  ation: "ate",
  ator: "ate",
  alism: "al",
  iveness: "ive",
  fulness: "ful",
  ousness: "ous",
  aliti: "al",
  iviti: "ive",
  biliti: "ble",
  logi: "log"
};
var step3list = {
  icate: "ic",
  ative: "",
  alize: "al",
  iciti: "ic",
  ical: "ic",
  ful: "",
  ness: ""
};
var consonant = "[^aeiou]";
var vowel = "[aeiouy]";
var consonants = "(" + consonant + "[^aeiouy]*)";
var vowels = "(" + vowel + "[aeiou]*)";
var gt0 = new RegExp("^" + consonants + "?" + vowels + consonants);
var eq1 = new RegExp("^" + consonants + "?" + vowels + consonants + vowels + "?$");
var gt1 = new RegExp("^" + consonants + "?(" + vowels + consonants + "){2,}");
var vowelInStem = new RegExp("^" + consonants + "?" + vowel);
var consonantLike = new RegExp("^" + consonants + vowel + "[^aeiouwxy]$");
var sfxLl = /ll$/;
var sfxE = /^(.+?)e$/;
var sfxY = /^(.+?)y$/;
var sfxIon = /^(.+?(s|t))(ion)$/;
var sfxEdOrIng = /^(.+?)(ed|ing)$/;
var sfxAtOrBlOrIz = /(at|bl|iz)$/;
var sfxEED = /^(.+?)eed$/;
var sfxS = /^.+?[^s]s$/;
var sfxSsesOrIes = /^.+?(ss|i)es$/;
var sfxMultiConsonantLike = /([^aeiouylsz])\1$/;
var step2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
var step3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
var step4 = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
function stemmer(value) {
  var firstCharacterWasLowerCaseY;
  var match;
  value = String(value).toLowerCase();
  if (value.length < 3) {
    return value;
  }
  if (value.charCodeAt(0) === 121) {
    firstCharacterWasLowerCaseY = true;
    value = "Y" + value.slice(1);
  }
  if (sfxSsesOrIes.test(value)) {
    value = value.slice(0, -2);
  } else if (sfxS.test(value)) {
    value = value.slice(0, -1);
  }
  if (match = sfxEED.exec(value)) {
    if (gt0.test(match[1])) {
      value = value.slice(0, -1);
    }
  } else if ((match = sfxEdOrIng.exec(value)) && vowelInStem.test(match[1])) {
    value = match[1];
    if (sfxAtOrBlOrIz.test(value)) {
      value += "e";
    } else if (sfxMultiConsonantLike.test(value)) {
      value = value.slice(0, -1);
    } else if (consonantLike.test(value)) {
      value += "e";
    }
  }
  if ((match = sfxY.exec(value)) && vowelInStem.test(match[1])) {
    value = match[1] + "i";
  }
  if ((match = step2.exec(value)) && gt0.test(match[1])) {
    value = match[1] + step2list[match[2]];
  }
  if ((match = step3.exec(value)) && gt0.test(match[1])) {
    value = match[1] + step3list[match[2]];
  }
  if (match = step4.exec(value)) {
    if (gt1.test(match[1])) {
      value = match[1];
    }
  } else if ((match = sfxIon.exec(value)) && gt1.test(match[1])) {
    value = match[1];
  }
  if ((match = sfxE.exec(value)) && (gt1.test(match[1]) || eq1.test(match[1]) && !consonantLike.test(match[1]))) {
    value = match[1];
  }
  if (sfxLl.test(value) && gt1.test(value)) {
    value = value.slice(0, -1);
  }
  if (firstCharacterWasLowerCaseY) {
    value = "y" + value.slice(1);
  }
  return value;
}

// src/search.ts
var Searcher = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.refreshDebounces();
    this.index = new import_flexsearch.Index({
      stemmer
    });
    this.results = { query: "", res: [] };
    this.indexes = {};
    this.notes = [];
  }
  search(query) {
    return __async(this, null, function* () {
      if (!this._index_updating)
        this.debouncedRefreshIndex();
      yield this._search(query);
    });
  }
  _search(query, offset = 0, paginate = false) {
    return __async(this, null, function* () {
      this.results = { query, res: [] };
      if (!query)
        return;
      let rs = this.index.search(query, {
        limit: this.plugin.settings.pageSize,
        offset,
        suggest: true
      });
      if (!(rs || rs.length)) {
      } else {
        for (let r of rs) {
          let n = this.notes.filter((n2) => n2.id == r)[0];
          this.results.res.push({
            id: n.id,
            name: n.name,
            link: n.link,
            type: n.type,
            highlightedSearch: this.highlightSearch(n.search, query),
            display: yield n.index.getDisplayFromOriginal(n.original)
          });
        }
      }
      let view = this.plugin.getView();
      if (!paginate)
        yield view.redraw();
      else if (rs.length > 0)
        yield view._redraw();
    });
  }
  removeIndex(idx) {
    return __async(this, null, function* () {
      yield idx.loadNotes();
      idx.notes.forEach((n) => this.index.remove(n.id));
      delete this.indexes[idx.type];
    });
  }
  addIndexIfNotAlreadyAdded(index) {
    if (!(index.type in this.indexes)) {
      this.indexes[index.type] = index;
      this.updateIndex(false, index);
    }
  }
  highlightSearch(searchText, query) {
    return searchText;
  }
  updateIndex(update = true, idx = "all") {
    return __async(this, null, function* () {
      this._index_updating = true;
      if (!(idx == "all"))
        yield this._doUpdateIndex(update, idx);
      else {
        for (let i in this.indexes) {
          yield this._doUpdateIndex(update, this.indexes[i]);
        }
      }
      this._refreshNotesList();
      this._index_updating = false;
    });
  }
  _doUpdateIndex(update, idx) {
    return __async(this, null, function* () {
      yield idx.loadNotes();
      if (update)
        idx.notes.forEach((n) => this.index.add(n.id, n.search));
      else {
        idx.notes.forEach((n) => {
          this.index.update(n.id, n.search);
        });
      }
    });
  }
  _refreshNotesList() {
    this.notes = [];
    for (let i in this.indexes) {
      this.indexes[i].notes.forEach((n) => {
        let searchNote = Object.assign({ index: this.indexes[i] }, n);
        this.notes.push(searchNote);
      });
    }
  }
  _searchCurrent(block) {
    let mv = this.plugin.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    if (mv) {
      let editor = mv.editor;
      if (block) {
        let query = "";
        let origLineNo = editor.getCursor().line;
        let lineCount = editor.lineCount();
        let lineNo = origLineNo;
        let line = editor.getLine(lineNo);
        while (line.length != 0) {
          line = editor.getLine(lineNo);
          if (line)
            query = line + ` ${query}`;
          if (lineNo == 0)
            break;
          lineNo -= 1;
        }
        lineNo = origLineNo + 1;
        line = editor.getLine(lineNo);
        while (line) {
          line = editor.getLine(lineNo);
          if (line)
            query += ` ${line}`;
          if (lineNo == lineCount - 1)
            break;
          lineNo += 1;
        }
        this.search(query);
      } else
        this.search(editor.getLine(editor.getCursor().line));
    }
  }
  _debRefreshIndexThenCall(func) {
    function new_function(args) {
      if (!this._index_updating)
        this.debouncedRefreshIndex();
      func(args);
    }
    return new_function;
  }
  refreshDebounces() {
    this.debouncedRefreshIndex = (0, import_obsidian4.debounce)(this.updateIndex, this.plugin.settings.refreshDebounce, true);
    this._debouncedSearch = (0, import_obsidian4.debounce)((query) => this.search(query), this.plugin.settings.searchDebounce, true);
    this._debouncedSearchCurrent = (0, import_obsidian4.debounce)((block) => this._searchCurrent(block), this.plugin.settings.searchDebounce, true);
    this.debouncedSearch = this._debRefreshIndexThenCall(this._debouncedSearch);
    this.debouncedSearchCurrent = this._debRefreshIndexThenCall(this._debouncedSearchCurrent);
  }
};

// src/settings.ts
var import_obsidian5 = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  searchDebounce: 1e3,
  refreshDebounce: 2e3,
  searchBlock: true,
  pageSize: 10,
  indexes: {}
};
var PowerSearchSettingsTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Power Search Settings" });
    new import_obsidian5.Setting(containerEl).setName("Search after time").setDesc("This is the time, in milliseconds, after you stop typing/stop selecting things that the search occurs (debounce timeout)").addSlider((slider) => slider.setLimits(500, 5e3, 100).setValue(this.plugin.settings.searchDebounce).setDynamicTooltip().onChange((value) => __async(this, null, function* () {
      this.plugin.settings.searchDebounce = value;
      yield this.plugin.saveSettings();
      this.plugin.search.refreshDebounces();
    })));
    new import_obsidian5.Setting(containerEl).setName("Refresh after time").setDesc("This is the time, in milliseconds, after you stop searching that the index refreshes i.e. changes to the searchable content are loaded into the search index (debounce timeout)").addSlider((slider) => slider.setLimits(3e3, 3e4, 500).setValue(this.plugin.settings.refreshDebounce).setDynamicTooltip().onChange((value) => __async(this, null, function* () {
      this.plugin.settings.refreshDebounce = value;
      yield this.plugin.saveSettings();
      this.plugin.search.refreshDebounces();
    })));
    new import_obsidian5.Setting(containerEl).setName("Search text blocks").setDesc(`For search on type, queries are built from blocks of text surrounded by whitespace if true and individual lines if false (RESTART REQUIRED TO ENACT CHANGES)`).addToggle((toggle) => toggle.setValue(this.plugin.settings.searchBlock).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.searchBlock = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerEl).setName("Page Size").setDesc(`Number of results shown per search result page`).addSlider((slider) => slider.setLimits(1, 100, 1).setValue(this.plugin.settings.pageSize).setDynamicTooltip().onChange((value) => __async(this, null, function* () {
      this.plugin.settings.pageSize = value;
      yield this.plugin.saveSettings();
    })));
    containerEl.createEl("h3", { text: "Search Indexes" });
    this.plugin.indexes.forEach((i) => {
      new import_obsidian5.Setting(containerEl).setName(i.type).setDesc(`Add notes of type ${i.type} to the content to be searched`).addToggle((toggle) => toggle.setValue(this.plugin.settings.indexes[i.type]).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.indexes[i.type] = value;
        yield this.plugin.saveSettings();
        yield i.setupIndex();
        this.plugin.getView().debouncedRedraw();
      })));
    });
  }
};

// src/view.ts
var import_obsidian6 = __toModule(require("obsidian"));
var SearchResultView = class extends import_obsidian6.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.debouncedRedraw = (0, import_obsidian6.debounce)(() => this.redraw(), 1e3);
    this.redraw();
  }
  redraw() {
    return __async(this, null, function* () {
      this.page = 1;
      yield this._redraw();
    });
  }
  _redraw() {
    return __async(this, null, function* () {
      let arrowEl = createDiv({ cls: "power-search-arrow-bar" });
      let leftArrow = arrowEl.createEl("a");
      leftArrow.innerHTML = "&laquo; ";
      leftArrow.classList.add("power-search-arrow-bar-item");
      leftArrow.addEventListener("click", () => this.prevPage());
      let pageNo = arrowEl.createSpan();
      pageNo.innerHTML = this.page.toString();
      pageNo.classList.add("power-search-arrow-bar-item");
      let rightArrow = arrowEl.createEl("a");
      rightArrow.classList.add("power-search-arrow-bar-item");
      rightArrow.innerHTML = " &raquo;";
      rightArrow.addEventListener("click", () => this.nextPage());
      let res = createDiv({ cls: "power-search-results-children" });
      let idxs = this.plugin.search.indexes;
      if (!Object.keys(idxs).length)
        res.createDiv({ cls: "power-search-results-type", text: "No indexes activated! They can be activated in the Power Search settings tab." });
      else if (this.plugin.search.results.res.length == 0)
        res.createDiv({ cls: "power-search-results-type", text: "No results found! Start highlighting text/typing to try to find results or check for any errors in loading indexes (in a notice that pops up a few times or the console)" });
      for (let e of this.plugin.search.results.res) {
        let ch = res.createDiv({ cls: "power-search-results-child" });
        let headEl = ch.createDiv({ cls: "power-search-results-type" });
        headEl.innerHTML = `<a href="${e.link}">${e.name}</a> Type: ${e.type}`;
        ch.append(e.display);
      }
      this.containerEl.children[1].empty();
      this.containerEl.children[1].append(arrowEl);
      this.containerEl.children[1].append(res);
    });
  }
  nextPage() {
    if (this.plugin.search.results.res.length) {
      this.page += 1;
      let off = (this.page - 1) * this.plugin.settings.pageSize;
      this.plugin.search._search(this.plugin.search.results.query, off, true);
    }
  }
  prevPage() {
    if (this.page != 1) {
      this.page -= 1;
      let off = (this.page - 1) * this.plugin.settings.pageSize;
      this.plugin.search._search(this.plugin.search.results.query, off, true);
    }
  }
  getViewType() {
    return SEARCH_RESULT_VIEW_TYPE;
  }
  getDisplayText() {
    return "Power Search";
  }
  getIcon() {
    return "search";
  }
};

// src/main.ts
var PowerSearch = class extends import_obsidian7.Plugin {
  onload() {
    return __async(this, null, function* () {
      console.log("Power Search plugin loading");
      yield this.loadSettings();
      this.indexes = [];
      this.registerView(SEARCH_RESULT_VIEW_TYPE, (leaf) => new SearchResultView(leaf, this));
      this.addCommands();
      this.search = new Searcher(this);
      this.app.workspace.onLayoutReady(() => this.initPlugin());
    });
  }
  initPlugin() {
    new AnkiIndex(this.search);
    new ObsidianIndex(this.search);
    this.addSettingTab(new PowerSearchSettingsTab(this.app, this));
    this.initLeaf();
    this.registerEvents();
  }
  addCommands() {
    this.addCommand({
      id: "open-power-search-results-view",
      name: "Open View",
      callback: () => this.initLeaf()
    });
  }
  registerEvents() {
    this.registerDomEvent(document, "selectionchange", () => {
      this.search.debouncedSearch(document.getSelection().toString());
    });
    this.registerDomEvent(document, "keydown", () => this.search.debouncedSearchCurrent(this.settings.searchBlock));
  }
  onunload() {
    console.log("Power Search plugin unloading");
    this.app.workspace.detachLeavesOfType(SEARCH_RESULT_VIEW_TYPE);
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  getView() {
    for (let leaf of this.app.workspace.getLeavesOfType(SEARCH_RESULT_VIEW_TYPE)) {
      let view = leaf.view;
      if (view instanceof SearchResultView) {
        return view;
      }
    }
    return null;
  }
  initLeaf() {
    let leaves = this.app.workspace.getLeavesOfType(SEARCH_RESULT_VIEW_TYPE);
    if (leaves.length) {
    } else {
      this.app.workspace.getRightLeaf(false).setViewState({
        type: SEARCH_RESULT_VIEW_TYPE,
        active: true
      });
    }
  }
};
