/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => ListCalloutsPlugin
});
var import_obsidian4 = __toModule(require("obsidian"));

// node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string) {
  if (typeof string !== "string") {
    throw new TypeError("Expected a string");
  }
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// src/settings.ts
var import_obsidian = __toModule(require("obsidian"));
var iconOptions = [
  "lucide-alert-triangle",
  "lucide-bookmark-plus",
  "lucide-bookmark",
  "lucide-bug",
  "lucide-calendar",
  "lucide-check-circle-2",
  "lucide-check",
  "lucide-clipboard-list",
  "lucide-clock",
  "lucide-flag",
  "lucide-flame",
  "lucide-heart",
  "lucide-help-circle",
  "lucide-highlighter",
  "lucide-info",
  "lucide-key",
  "lucide-list",
  "lucide-map-pin",
  "lucide-megaphone",
  "lucide-message-circle",
  "lucide-pencil",
  "lucide-slash",
  "lucide-star",
  "lucide-thumbs-down",
  "lucide-thumbs-up",
  "lucide-trash2",
  "lucide-x",
  "lucide-zap",
  "quote-glyph"
];
function buildSettingCallout(root, callout) {
  root.empty();
  root.createDiv({
    cls: "markdown-source-view cm-s-obsidian mod-cm6 is-readable-line-width is-live-preview"
  }, (mockSrcView) => {
    mockSrcView.createDiv({
      cls: "HyperMD-list-line HyperMD-list-line-1 lc-list-callout cm-line",
      attr: {
        style: `text-indent: -8px; padding-left: 12px; --lc-callout-color: ${callout.color}`
      }
    }, (mockListLine) => {
      mockListLine.createSpan({
        cls: "cm-formatting cm-formatting-list cm-formatting-list-ul cm-list-1"
      }, (span) => {
        span.createSpan({ cls: "list-bullet", text: "-" });
        span.appendText(" ");
      });
      mockListLine.createSpan({ cls: "lc-list-bg" });
      mockListLine.createSpan({ cls: "lc-list-marker" }, (span) => {
        if (callout.icon) {
          (0, import_obsidian.setIcon)(span, callout.icon);
        } else {
          span.appendText(callout.char);
        }
      });
      mockListLine.createSpan({
        cls: "cm-list-1",
        text: " Sed eu nisl rhoncus, consectetur mi quis, scelerisque enim."
      });
    });
  });
}
function buildSetting(containerEl, plugin, index, callout) {
  containerEl.createDiv({ cls: "lc-setting" }, (el) => {
    const calloutContainer = el.createDiv({ cls: "lc-callout-container" });
    buildSettingCallout(calloutContainer, callout);
    el.createDiv({ cls: "lc-input-container" }, (inputContainer) => {
      new import_obsidian.TextComponent(inputContainer).setValue(callout.char).onChange((value) => {
        if (!value)
          return;
        plugin.settings[index].char = value;
        plugin.saveSettings();
        buildSettingCallout(calloutContainer, plugin.settings[index]);
      });
      new import_obsidian.ButtonComponent(inputContainer).then((btn) => {
        if (callout.icon) {
          btn.setIcon(callout.icon);
        } else {
          btn.setButtonText("Set Icon");
        }
        btn.onClick((e) => {
          var _a;
          const menu = new import_obsidian.Menu();
          (_a = menu.dom) == null ? void 0 : _a.addClass("lc-menu");
          menu.addItem((item) => {
            item.setTitle("No icon");
            item.onClick(() => {
              delete plugin.settings[index].icon;
              plugin.saveSettings();
              buildSettingCallout(calloutContainer, plugin.settings[index]);
              btn.buttonEl.empty();
              btn.setButtonText("Set Icon");
            });
          });
          iconOptions.forEach((icon) => {
            menu.addItem((item) => {
              item.setIcon(icon);
              item.onClick(() => {
                plugin.settings[index].icon = icon;
                plugin.saveSettings();
                buildSettingCallout(calloutContainer, plugin.settings[index]);
                btn.buttonEl.empty();
                btn.setIcon(icon);
              });
            });
          });
          menu.showAtMouseEvent(e);
        });
      });
    });
  });
}
var ListCalloutSettings = class extends import_obsidian.PluginSettingTab {
  constructor(plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setDesc(createFragment((f) => {
      f.appendText("See the Style Settings plugin for additional configuration options.");
      f.append(createEl("br"));
      f.append(createEl("strong", {
        text: "Note: Using +, *, -, >, or # as the callout character can disrupt reading mode."
      }));
    }));
    this.plugin.settings.forEach((callout, index) => {
      buildSetting(containerEl, this.plugin, index, callout);
    });
  }
};

// src/extension.ts
var import_view = __toModule(require("@codemirror/view"));
var import_state = __toModule(require("@codemirror/state"));
var import_obsidian2 = __toModule(require("obsidian"));
var setConfig = import_state.StateEffect.define();
var CalloutBackground = class extends import_view.WidgetType {
  toDOM() {
    return createSpan({
      cls: "lc-list-bg",
      attr: {
        "aria-hidden": "true"
      }
    });
  }
};
var CalloutMarker = class extends import_view.WidgetType {
  constructor(char, icon) {
    super();
    this.char = char;
    this.icon = icon;
  }
  toDOM() {
    return createSpan({
      text: this.char,
      cls: "lc-list-marker",
      attr: {
        "aria-hidden": "true"
      }
    }, (s) => {
      if (this.icon) {
        (0, import_obsidian2.setIcon)(s, this.icon);
      }
    });
  }
};
var calloutDecoration = (color) => import_view.Decoration.line({
  attributes: {
    class: "lc-list-callout",
    style: `--lc-callout-color: ${color}`
  }
});
var calloutsConfigField = import_state.StateField.define({
  create() {
    return [];
  },
  update(state, tr) {
    for (const e of tr.effects) {
      if (e.is(setConfig)) {
        state = e.value;
      }
    }
    return state;
  }
});
function buildCalloutDecos(view) {
  const config = view.state.field(calloutsConfigField);
  if (!config.length)
    return import_view.Decoration.none;
  const builder = new import_state.RangeSetBuilder();
  for (const { from, to } of view.visibleRanges) {
    for (let pos = from; pos <= to; ) {
      const line = view.state.doc.lineAt(pos);
      for (const callout of config) {
        const match = line.text.match(callout.re);
        if (match) {
          const labelPos = line.from + match[1].length;
          builder.add(line.from, line.from, calloutDecoration(callout.color));
          builder.add(labelPos, labelPos, import_view.Decoration.replace({
            widget: new CalloutBackground(),
            side: 1
          }));
          builder.add(labelPos, labelPos + callout.char.length, import_view.Decoration.replace({
            widget: new CalloutMarker(callout.char, callout.icon)
          }));
          break;
        }
      }
      pos = line.to + 1;
    }
  }
  return builder.finish();
}
var calloutExtension = import_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = buildCalloutDecos(view);
  }
  update(update) {
    if (update.docChanged || update.viewportChanged || update.transactions.some((tr) => tr.effects.some((e) => e.is(setConfig)))) {
      this.decorations = buildCalloutDecos(update.view);
    }
  }
}, {
  decorations: (v) => v.decorations
});

// src/postProcessor.ts
var import_obsidian3 = __toModule(require("obsidian"));
function getFirstTextNode(li) {
  var _a;
  let node = li.firstChild;
  if ((node == null ? void 0 : node.nodeType) !== document.TEXT_NODE || node.nodeValue === "\n" || node.nodeValue === "\r\n") {
    if ((node == null ? void 0 : node.nodeType) === document.TEXT_NODE && (node.nodeValue === "\n" || node.nodeValue === "\r\n")) {
      node = node.nextSibling;
    }
    if ((node == null ? void 0 : node.nodeType) === document.ELEMENT_NODE) {
      if (node.hasClass("list-collapse-indicator")) {
        node = node.nextSibling;
      }
      if ((node == null ? void 0 : node.nodeType) === document.TEXT_NODE && (node.nodeValue === "\n" || node.nodeValue === "\r\n")) {
        node = node.nextSibling;
      }
      if ((node == null ? void 0 : node.nodeType) === document.TEXT_NODE) {
      } else if ((node == null ? void 0 : node.nodeType) === document.ELEMENT_NODE && ((_a = node.firstChild) == null ? void 0 : _a.nodeType) === document.TEXT_NODE) {
        node = node.firstChild;
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  return node;
}
function wrapLiContent(li) {
  const toReplace = [];
  let insertBefore = null;
  for (let i = 0, len = li.childNodes.length; i < len; i++) {
    const child = li.childNodes.item(i);
    if (child.nodeType === document.ELEMENT_NODE) {
      if (child.hasClass("list-collapse-indicator")) {
        continue;
      }
      if (["UL", "OL"].includes(child.tagName)) {
        insertBefore = child;
        break;
      }
    }
    toReplace.push(child);
  }
  const wrapper = createSpan({ cls: "lc-li-wrapper" });
  toReplace.forEach((node) => wrapper.append(node));
  if (insertBefore) {
    insertBefore.before(wrapper);
  } else {
    li.append(wrapper);
  }
}
function buildPostProcessor(getConfig) {
  return (el) => {
    const config = getConfig();
    el.findAll("li").forEach((li) => {
      const node = getFirstTextNode(li);
      if (!node)
        return;
      const text = node.textContent;
      if (!text)
        return;
      for (const callout of config) {
        const match = text.match(callout.re);
        if (match) {
          li.addClass("lc-list-callout");
          li.style.setProperty("--lc-callout-color", callout.color);
          node.replaceWith(createFragment((f) => {
            f.append(createSpan({
              cls: "lc-list-marker",
              text: text.slice(0, callout.char.length)
            }, (span) => {
              if (callout.icon) {
                (0, import_obsidian3.setIcon)(span, callout.icon);
              }
            }));
            f.append(text.slice(callout.char.length));
          }));
          wrapLiContent(li);
          break;
        }
      }
    });
  };
}

// src/main.ts
var DEFAULT_SETTINGS = [
  {
    color: "255, 214, 0",
    char: "&"
  },
  {
    color: "255, 145, 0",
    char: "?"
  },
  {
    color: "255, 23, 68",
    char: "!"
  },
  {
    color: "124, 77, 255",
    char: "~"
  },
  {
    color: "0, 184, 212",
    char: "@"
  },
  {
    color: "0, 200, 83",
    char: "$"
  },
  {
    color: "158, 158, 158",
    char: "%"
  }
];
var ListCalloutsPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.emitSettingsUpdate = (0, import_obsidian4.debounce)(() => this.dispatchUpdate(), 2e3, true);
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.buildPostProcessorConfig();
      this.addSettingTab(new ListCalloutSettings(this));
      this.emitter = new import_obsidian4.Events();
      this.registerMarkdownPostProcessor(buildPostProcessor(() => this.postProcessorConfig));
      this.registerEditorExtension([
        calloutsConfigField.init(() => {
          return this.buildEditorConfig();
        }),
        calloutExtension
      ]);
      app.workspace.trigger("parse-style-settings");
    });
  }
  dispatchUpdate() {
    const newConfig = this.buildEditorConfig();
    app.workspace.getLeavesOfType("markdown").find((l) => {
      const view = l.view;
      const cm = view.editor.cm;
      cm == null ? void 0 : cm.dispatch({
        effects: [setConfig.of(newConfig)]
      });
    });
  }
  buildEditorConfig() {
    return this.settings.map((callout) => {
      return __spreadProps(__spreadValues({}, callout), {
        re: new RegExp(`(^\\s*[-*+] |^\\s*\\d+[\\.\\)] )${escapeStringRegexp(callout.char)} `)
      });
    });
  }
  buildPostProcessorConfig() {
    this.postProcessorConfig = this.settings.map((callout) => {
      return __spreadProps(__spreadValues({}, callout), {
        re: new RegExp(`^${escapeStringRegexp(callout.char)} `)
      });
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      const loadedSettings = yield this.loadData();
      this.settings = DEFAULT_SETTINGS.map((s, i) => {
        return Object.assign({}, s, loadedSettings ? loadedSettings[i] : {});
      });
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
      this.emitSettingsUpdate();
      this.buildPostProcessorConfig();
    });
  }
};
